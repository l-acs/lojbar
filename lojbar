#!/bin/clojure
; -*-Clojure-*-
(require '[clojure.string :as str])
(require '[clojure.java.io :as io])
(require '[clojure.edn :as edn])
(use '[clojure.java.shell :only [sh]])
(import 'java.lang.Runtime)
(import 'java.io.BufferedReader)
(import 'java.io.InputStreamReader)

(defn exec [arg & args] ; passes a command, and optionally arguments, to `sh`
  (:out (sh "sh" "-c" (str/join " " (flatten (list arg args))))))

(defn focus [color]
  {  :true (str "%{F#" (color :opaque) (color :f-base) "}%{B#" (color :opaque) (color :b-base) "}")
     :false (str "%{F#" (color :mid) (color :f-base) "}%{B#" (color :transparent) (color :b-base) "}")
     :urgent "something"
     :none (str "%{F#" (color :none) (color :f-base) "}%{B#" (color :none) (color :b-base) "}")
     :dimmed (str "%{F#" (color :transparent) (color :f-base) "}%{B#" (color :transparent) (color :b-base) "}")})

(defn makebuttons [message actions ref]
  ;%{A1:action:}%{A3:action:}...%{A}%{A}
  (reduce (fn [msg [key action]] (str "%{A" (ref key) ":" action ":}" msg "%{A}")) message actions))

(defn bspwm-getdesktoplist [output]
  (filter #(re-matches #"[fFoO].*" %) (str/split output #":")))

(defn bspwm-desktop-isactive? [s]
  (re-matches #"[A-Z].*" s))

(defn bspwm-desktop-haswindows? [s]
  (re-matches #"[oO].*" s))

(defn bspwm-desktop-getname [s]
  (-> s (str/split #"")  rest str/join))

(defn bspwm-makedesktopbutton [index d foci ref]
  (let [haswindows? (bspwm-desktop-haswindows? d)
        isactive? (bspwm-desktop-isactive? d)]
    (if (and (not haswindows?) (not isactive?))
      ""
      (str
       (-> isactive? some? str keyword foci)
       (makebuttons
        (str " " (bspwm-desktop-getname d) " ") {:right (str "$HOME/.scripts/window/act.sh -s " index) :left (str "$HOME/.scripts/window/act.sh --capturefocuscapture " index) :in (str "$HOME/.scripts/window/act.sh --showthumbnail " index)} ref)))))

(defn bspwm-nulldesktopbutton [foci ref]
  (str (:false foci) " "
       (makebuttons  ""
                    {:left "bspc desktop -f next.!occupied"
                     :right "bspc node -d next.!occupied"}
                    ref)))

(defn bspwm-desktops [output foci ref]
  (str
   (makebuttons
    (str/join
     (map-indexed #(bspwm-makedesktopbutton (+ 1 %1) %2 foci ref) (bspwm-getdesktoplist output)))
    {:up "bspc desktop -f next.local.occupied" 
     :down "bspc desktop -f prev.local.occupied" } ref)
   (bspwm-nulldesktopbutton foci ref)))

(defn add-elem-if-not-chr-dup [[lst chr] elem] [(if (= elem (first lst) chr) lst (cons elem lst)) chr])

(defn squeeze [string chr] ;for parsing text alignment of wmctrl output, mostly
  (str/join (reverse (first (reduce add-elem-if-not-chr-dup ['() chr] (str/split string #""))))))

(defn getwm []
  (-> "wmctrl -m" exec (str/split #"\n") first (str/split #"\s") second))

(defn getdesktoplist []
  (->> (str/split (exec "wmctrl -d") #"\n") 
       (map #(squeeze % " "))
       (map #(str/split % #"\s"))))

(defn getindex [desktop wm]
  (let [x (-> desktop (nth 0) read-string)]
    (str (if (= wm "CWM") x (+ x 1)))))

(defn getwindows [desktop wm] ;desktop is one line of the output of wmctrl -d
  (exec "xdotool search --desktop" (nth desktop 0) "\"\"" ))

(defn isactive? [desktop] ; only works one at a time in CWM
  (= "*" (nth desktop 1)))

(defn haswindows? [desktop wm] ;causing problems
  (not (str/blank? (getwindows desktop wm))))

(defn getname [desktop wm]
  (case wm
    ("awesome" "bspwm") (nth desktop 8)
    "CWM" (nth desktop 9)
    nil))

(defn makedesktopbutton [d wm foci ref]
  (let [index (getindex d wm)]
    (str
     ((if (isactive? d) :true (if (haswindows? d wm) :false :dimmed)) foci)
     (makebuttons
      (str " " (getname d wm) " ") {:right (str "$HOME/.scripts/window/act.sh -s " index) :left (str "$HOME/.scripts/window/act.sh --capturefocuscapture " index) :in (str "$HOME/.scripts/window/act.sh --showthumbnail " index)} ref))))

(defn desktops [wm foci ref]
  (makebuttons
   (str/join (drop (if (= wm "CWM") 1 0) (map #(makedesktopbutton % wm foci ref) (getdesktoplist))))
   {:up "$HOME/.scripts/window/act.sh --capturefocuscapture next" :down "$HOME/.scripts/window/act.sh --capturefocuscapture prev"} ref))

(defn music [server ref]
  (let [serverprefix (if server (str "ssh " server " ") "")
        affix #(into {} (map (fn [[k v]] [k (str serverprefix v " &")]) %)) ]
    (str
     (makebuttons "  \uf104 " (affix {:left "mpc prev" :right "mpc seek 0"}) ref)
     (makebuttons
      (first (str/split-lines (exec (str serverprefix "mpc current | sed 's/[[(].*\\([Aa]coustic\\|[Ll]ive\\|[Mm]aster\\|[Vv]ersion\\|[Ee]dit\\|[Mm]ix\\).*[])]//g'"))))
      (affix {:left "mpc toggle" :middle "urxvt -e ncmpcpp -s lyrics" :right "mpc sendmessage mpdas love" :up "mpc volume +5" :down "mpc volume -5"}) ref)
     (makebuttons " \uf105  " (affix {:left "mpc next"}) ref)))) 

(defn date [format] (nth (str/split (:out (sh "date" format)) #"\n") 0))

(defn bat-emoji-format [bat offset section-count] ; f244 f243 f242 f241 f240
  (->> bat (+ 24 (- offset)) (* (/ section-count 100)) int (- 4)  (+ 62016) Character/toChars (apply str))) ; offset of 0 means empty is 0, 1/4 is 1-25, 1/2 is 26-50, 3/4 is 51-75, full is 76-100 where section-count is 4

(defn battery [info foci]
  (if (reduce #(and %1 %2) (map #(-> % info io/file .exists) '(:cap :status)))
    (let [current (-> info :cap slurp str/trim-newline read-string)]
      (if (-> info :status  slurp str/trim-newline (= "Charging"))
        (str (:false foci) " \uf5e7: " current "%")
        (-> current (< (info :threshold)) str keyword foci (str (bat-emoji-format current (info :offset) (info :sections)) ": " current "%"))))   ""))

(defn volume [ref]
  (makebuttons (str " " (first (str/split-lines (exec "volume query"))) " ") {:up "volume +" :down "volume -" :left "volume toggle" :right "volume mute"} ref))

(defn brightness [info ref]
  (if (reduce #(and %1 %2) (map #(-> % info io/file .exists) '(:current :max)))
    (makebuttons (str "\uf185: "  (->> (map #(-> % first info slurp read-string) info) (apply /) float (* 100) int) "%") 
      {:up "brightnessctl set +10" :down "brightnessctl set 10-"} ref) ""))

(defn store-cmd-in-atom! [a & args]
  (let [proc (.exec (Runtime/getRuntime) (into-array args))]
    (with-open [rdr (BufferedReader. (InputStreamReader. (.getInputStream proc)))]
      (dorun
       (map #(reset! a %)
        (take-while  #(pos? (.length %))
              (repeatedly #(.readLine rdr))))))))

(defn run-on-atom-change [a func]
  (add-watch a :watcher
    (fn [key atom old-state new-state] (eval func))))

(defn update-atom-at-interval! [a time func]
  (while true (Thread/sleep time) (reset! a (eval func))))

(def wm (getwm))
(def config (-> ".config/lojbar/config.edn" slurp edn/read-string))

(def foci (focus (:color config)))
(def bat (:bat config))
(def bright (:bright config))
(def server (:server config))
(def button-ref {:left 1 :middle 2 :right 3 :up (if (:natural-scrolling config) 5 4) :down (if (:natural-scrolling config) 4 5) :in 6 :out 7})
(def scroll (if (:natural-scrolling config) '(5 4) '(4 5)))
(def date-format (:date-format config))

(def atoms (into {} (map (fn [k] [k (atom "")]) '(:d :v :m :b :t :br))))


(future (if (= wm "bspwm")
    (store-cmd-in-atom! (atoms :d) "bspc" "subscribe")
    (update-atom-at-interval! (atoms :d) '(desktops wm foci button-ref))))
(future (store-cmd-in-atom! (atoms :v) "pactl" "subscribe")) 
(dorun (map #(future (update-atom-at-interval! (atoms %2) %1 %3)) '(500 500 5000 1000) '(:m :br :b :t) (list '(music server button-ref) '(brightness bright button-ref) '(battery bat foci) '(date date-format)))) ; set update times and function calls for each polling module

(defn spew [foci]
  (println
   (foci :false) "%{l}  " (if (= wm "bspwm") (bspwm-desktops @(atoms :d) foci button-ref) @(atoms :d))
   (foci :false) "%{c}" @(atoms :m) (volume button-ref)
   "%{r}" @(atoms :b) (foci :false) @(atoms :br) " " @(atoms :t)  "  "))

(doseq [[_ a] atoms] (run-on-atom-change a '(spew foci))) ; update the bar whenever a module updates
