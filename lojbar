#!/bin/clojure
; -*-Clojure-*-
(require '[clojure.string :as str])
(require '[clojure.java.io :as io])
(use '[clojure.java.shell :only [sh]])
(import 'java.lang.Runtime)

(defn remove-back-to-back [lst item]
  (defn helper [lst item prev]
    (if (empty? lst)
      '()
      (if (= prev (first lst) item)
        (helper (rest lst) item item)
        (cons (first lst) (helper (rest lst) item (first lst))))))
  (helper lst item ""))

(defn squeeze [string chr] ;for parsing text alignment of wmctrl output, mostly
  (str/join 
   (remove-back-to-back (str/split string #"") chr)))

(defn exec [cmd]
  (:out 
   (apply sh (str/split cmd #"\s"))))

(defn focus [color]
  {  :true (str "%{F#" (color :opaque) (color :f-base) "}%{B#" (color :opaque) (color :b-base) "}")
     :false (str "%{F#" (color :mid) (color :f-base) "}%{B#" (color :transparent) (color :b-base) "}")
     :urgent "something"
     :none (str "%{F#" (color :none) (color :f-base) "}%{B#" (color :none) (color :b-base) "}")
     :dimmed (str "%{F#" (color :transparent) (color :f-base) "}%{B#" (color :transparent) (color :b-base) "}")})

(defn makebuttons [message actions buttons]
  ;%{A1:action:}%{A3:action:}...%{A}%{A}
  (if (empty? actions)
    message
    (makebuttons (str "%{A" (first buttons) ":" (first actions) ":}" message "%{A}") (rest actions) (rest buttons))))


(defn music []
  (str
   (makebuttons "  <  " '("mpc prev" "mpc seek 0") (list 1 3))
   (makebuttons
    (first (str/split (exec "mpc current") #"\n"))
    '("mpc toggle" "urxvt -e ncmpcpp -s lyrics &" "mpc volume +5" "mpc volume -5") (list 1 3 4 5))
   (makebuttons "  >  " '("mpc next" "mpc next") (list 1 3))))


(defn getwm []
  (second
   (str/split
    (first (str/split (exec "wmctrl -m") #"\n"))
    #"\s")))


(defn getdesktoplist [] 
  (map
   #(str/split % #"\s")
   (map (fn [x] (squeeze x " ")) (str/split (exec "wmctrl -d") #"\n"))))


(defn getindex [desktop wm]
  (if (= wm "CWM")
    (str (nth desktop 0)))
    (str (+ (read-string (str (nth desktop 0))) 1)))


(defn getwindows [desktop wm] ;desktop is one line of the output of wmctrl -d
  (:out
   (sh "xdotool" "search" "--desktop" ;"$HOME/.scripts/window/act.sh" "--getwindowsfordesktop"
       (nth desktop 0) "" )))
       ;xdotool counts from 0, so it doesn't vary by WM; otherwise getindex would be better. the "" is xdotool only


(defn isactive? [desktop] ; only works one at a time in CWM
  (= "*" (nth desktop 1)))

(defn haswindows? [desktop wm] ;causing problems
  (not (str/blank? (getwindows desktop wm))))

(defn getname [desktop wm]
  (case wm
    "bspwm" (nth desktop 8)
    "CWM" (nth desktop 9)
    nil))

(defn makedesktopbutton [d wm foci]
  (def index (getindex d wm))
  (str
    ((if (isactive? d) :true (if (haswindows? d wm) :false :dimmed)) foci)
   (makebuttons
    (str " " (getname d wm) " ") (list (str "$HOME/.scripts/window/act.sh -s " index) (str "$HOME/.scripts/window/act.sh --capturefocuscapture " index) (str "$HOME/.scripts/window/act.sh --showthumbnail " index)) (list 3 1 6))))


(defn desktops [wm foci]
  (makebuttons
   (str/join (drop (if (= wm "CWM") 1 0) (map #(makedesktopbutton % wm foci) (getdesktoplist))))
   '("$HOME/.scripts/window/act.sh --capturefocuscapture next" "$HOME/.scripts/window/act.sh --capturefocuscapture prev") '(4 5)))

(defn date [] (nth (str/split (:out (sh "date" "+%a, %b %-d %Y - %-I:%M%P")) #"\n") 0))

(defn battery [info foci]
  (if (and (.exists (io/file (info :cap))) (.exists (io/file (info :status))))
     (if (= "Charging" (str/trim-newline (slurp (info :status))))
       (str (:false foci) " " (str/trim-newline (slurp (info :cap))) "%" " - charging")
       (str (if (< (read-string (str/trim-newline (slurp (info :cap)))) (info :threshold))
              (:true foci)
              (:false foci))
            " " (str/trim-newline (slurp (info :cap))) "% "))
     "" ))


(defn volume [foci]
  (str (:false foci)
       (makebuttons (first (str/split-lines (exec "volume query"))) (list "volume +" "volume -" "volume toggle" "volume mute") (list 4 5 1 3))))



; volume module:
; pactl subscribe | while read line; do echo $line | grep -q sink && volume query | sed q; done 



(def color {:f-base "FFFFFF" :b-base "111111" :none "00" :transparent "90" :mid "C4" :opaque "E9"})
(def bat {:cap "/sys/class/power_supply/BAT0/capacity" :status "/sys/class/power_supply/BAT0/status" :threshold 25})
(def foci (focus color))
(def wm (getwm))

(def atoms {:d (atom (desktops wm foci)) :m (atom (music)) :v (atom (volume foci)) :b (atom (battery bat foci)) :t (atom (date))})

(future (while true (Thread/sleep 100) (reset! (atoms :d) (desktops wm foci))))
(future (while true (Thread/sleep 500) (reset! (atoms :m) (music))))
(future (while true (Thread/sleep 500) (reset! (atoms :v) (volume foci))))
(future (while true (Thread/sleep 5000) (reset! (atoms :b) (battery bat foci))))
(future (while true  (Thread/sleep 1000) (reset! (atoms :t) (date))))

(defn spew [foci]
  (println
   (foci :false) "%{l}  " @(atoms :d)
   (foci :false) "%{c}" @(atoms :m) @(atoms :v)
   "%{r}" @(atoms :b) (foci :false) " " @(atoms :t)  "  "))

(while true
  (Thread/sleep 100)
  (spew foci))

(shutdown-agents) ;without this it hangs
