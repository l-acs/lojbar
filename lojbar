#!/bin/clojure
; -*-Clojure-*-
(require '[clojure.string :as str])
(require '[clojure.java.io :as io])
(require '[clojure.edn :as edn])
(use '[clojure.java.shell :only [sh]])
(import 'java.lang.Runtime)

(defn remove-back-to-back [lst item]
  (defn helper [lst item prev]
    (if (empty? lst)
      '()
      (if (= prev (first lst) item)
        (helper (rest lst) item item)
        (cons (first lst) (helper (rest lst) item (first lst))))))
  (helper lst item ""))

(defn squeeze [string chr] ;for parsing text alignment of wmctrl output, mostly
  (str/join 
   (remove-back-to-back (str/split string #"") chr)))

(defn exec [cmd]
  (:out 
   (apply sh (str/split cmd #"\s"))))

(defn focus [color]
  {  :true (str "%{F#" (color :opaque) (color :f-base) "}%{B#" (color :opaque) (color :b-base) "}")
     :false (str "%{F#" (color :mid) (color :f-base) "}%{B#" (color :transparent) (color :b-base) "}")
     :urgent "something"
     :none (str "%{F#" (color :none) (color :f-base) "}%{B#" (color :none) (color :b-base) "}")
     :dimmed (str "%{F#" (color :transparent) (color :f-base) "}%{B#" (color :transparent) (color :b-base) "}")})

(defn makebuttons [message actions buttons]
  ;%{A1:action:}%{A3:action:}...%{A}%{A}
  (if (empty? actions)
    message
    (makebuttons (str "%{A" (first buttons) ":" (first actions) ":}" message "%{A}") (rest actions) (rest buttons))))


(defn music [server]
  (let [serverprefix (if server (str "ssh " server " ") "")
        affix (fn [x] (map #(str serverprefix % " &") x)) ]
    (str
     (makebuttons "  <  " (affix '("mpc prev" "mpc seek 0")) (list 1 3))
     (makebuttons
      (first (str/split (exec (str serverprefix "mpc current")) #"\n"))
      (affix '("mpc toggle" "mpc sendmessage mpdas love" "urxvt -e ncmpcpp -s lyrics &" "mpc volume +5" "mpc volume -5")) (list 1 2 3 4 5))
     (makebuttons "  >  " (affix '("mpc next" "mpc next")) (list 1 3)))))


(defn getwm []
  (-> "wmctrl -m" exec (str/split #"\n") first (str/split #"\s") second))

(defn getdesktoplist []
  (->> (str/split (exec "wmctrl -d") #"\n") 
       (map #(squeeze % " "))
       (map #(str/split % #"\s"))))


(defn getindex [desktop wm]
  (let [x (-> desktop (nth 0) read-string)]
    (str (if (= wm "CWM") x (+ x 1)))))


(defn getwindows [desktop wm] ;desktop is one line of the output of wmctrl -d
  (:out (sh "xdotool" "search" "--desktop" (nth desktop 0) "" )))

(defn isactive? [desktop] ; only works one at a time in CWM
  (= "*" (nth desktop 1)))

(defn haswindows? [desktop wm] ;causing problems
  (not (str/blank? (getwindows desktop wm))))

(defn getname [desktop wm]
  (case wm
    "awesome" (nth desktop 8)
    "bspwm" (nth desktop 8)
    "CWM" (nth desktop 9)
    nil))

(defn makedesktopbutton [d wm foci]
  (let [index (getindex d wm)]
    (str
     ((if (isactive? d) :true (if (haswindows? d wm) :false :dimmed)) foci)
     (makebuttons
      (str " " (getname d wm) " ") (list (str "$HOME/.scripts/window/act.sh -s " index) (str "$HOME/.scripts/window/act.sh --capturefocuscapture " index) (str "$HOME/.scripts/window/act.sh --showthumbnail " index)) (list 3 1 6)))))


(defn desktops [wm foci]
  (makebuttons
   (str/join (drop (if (= wm "CWM") 1 0) (map #(makedesktopbutton % wm foci) (getdesktoplist))))
   '("$HOME/.scripts/window/act.sh --capturefocuscapture next" "$HOME/.scripts/window/act.sh --capturefocuscapture prev") '(4 5)))

(defn date [] (nth (str/split (:out (sh "date" "+%a, %b %-d %Y - %-I:%M%P")) #"\n") 0))

(defn battery [info foci] 
  (if (reduce #(and %1 %2) (map #(-> % info io/file .exists) '(:cap :status)))
    (let [current (-> info :cap slurp str/trim-newline read-string)]
      (if (-> info :status  slurp str/trim-newline (= "Charging"))
        (str (:false foci) " " current "% - charging")
        (-> current (< (info :threshold)) str keyword foci (str " " current "%"))))   ""))


(defn volume [foci]
  (str (:false foci)
       (makebuttons (first (str/split-lines (exec "volume query"))) (list "volume +" "volume -" "volume toggle" "volume mute") (list 4 5 1 3))))


(defn brightness [info foci]
  (if (reduce #(and %1 %2) (map #(-> % info io/file .exists) '(:current :max)))
    (makebuttons (str "Bright: "  (->> (map #(-> % first info slurp read-string) info) (apply /) float (* 100) int) "%") 
      (list "brightnessctl set 10-" "brightnessctl set +10")  (list 4 5))  ""))
 

(def wm (getwm))
(def config (-> ".config/lojbar/config.edn" slurp edn/read-string))

(def foci (focus (:color config)))
(def bat (:bat config))
(def bright (:bright config))
(def server (:server config))

(def atoms
  {:d (atom (desktops wm foci))
   :m (atom (music server))
   :v (atom (volume foci))
   :b (atom (battery bat foci))
   :t (atom (date))
   :br (atom (brightness bright foci)) })

(future (while true (Thread/sleep 100) (reset! (atoms :d) (desktops wm foci))))
(future (while true (Thread/sleep 500) (reset! (atoms :m) (music server))))
(future (while true (Thread/sleep 500) (reset! (atoms :v) (volume foci))))
(future (while true (Thread/sleep 500) (reset! (atoms :br) (brightness bright foci))))
(future (while true (Thread/sleep 5000) (reset! (atoms :b) (battery bat foci))))
(future (while true (Thread/sleep 1000) (reset! (atoms :t) (date))))

(defn spew [foci]
  (println
   (foci :false) "%{l}  " @(atoms :d)
   (foci :false) "%{c}" @(atoms :m) @(atoms :v)
   "%{r}" @(atoms :b) "   " (foci :false) @(atoms :br) " " @(atoms :t)  "  "))

(while true
  (Thread/sleep 100)
  (spew foci))

(shutdown-agents) ;without this it hangs
