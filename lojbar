#!/bin/clojure
; -*-Clojure-*-
(require '[clojure.string :as str])
(require '[clojure.java.io :as io])
(require '[clojure.edn :as edn])
(use '[clojure.java.shell :only [sh]])
(import 'java.lang.Runtime)
(import 'java.io.BufferedReader)
(import 'java.io.InputStreamReader)

(defn exec [arg & args] ; passes a command, and optionally arguments, to `sh`
  (:out (sh "sh" "-c" (str/join " " (flatten (list arg args))))))

(defn focus [color]
  {  :true (str "%{F#" (color :opaque) (color :f-base) "}%{B#" (color :opaque) (color :b-base) "}")
     :false (str "%{F#" (color :mid) (color :f-base) "}%{B#" (color :transparent) (color :b-base) "}")
     :urgent "something"
     :none (str "%{F#" (color :none) (color :f-base) "}%{B#" (color :none) (color :b-base) "}")
     :dimmed (str "%{F#" (color :transparent) (color :f-base) "}%{B#" (color :transparent) (color :b-base) "}")})

(defn makebuttons [message actions buttons]
  ;%{A1:action:}%{A3:action:}...%{A}%{A}
  (let [buttons (flatten buttons)]
    (if (empty? actions)
      message
      (makebuttons (str "%{A" (first buttons) ":" (first actions) ":}" message "%{A}") (rest actions) (rest buttons)))))

(defn bspwm-getdesktoplist [output]
  (filter #(re-matches #"[fFoO].*" %) (str/split output #":")))

(defn bspwm-desktop-isactive? [s]
  (re-matches #"[A-Z].*" s))

(defn bspwm-desktop-haswindows? [s]
  (re-matches #"[oO].*" s))

(defn bspwm-desktop-getname [s]
  (-> s (str/split #"")  rest str/join))

(defn bspwm-makedesktopbutton [index d foci]
  (str
     ((if (bspwm-desktop-isactive? d) :true (if (bspwm-desktop-haswindows? d) :false :dimmed)) foci)
     (makebuttons
      (str " " (bspwm-desktop-getname d) " ") (list (str "$HOME/.scripts/window/act.sh -s " index) (str "$HOME/.scripts/window/act.sh --capturefocuscapture " index) (str "$HOME/.scripts/window/act.sh --showthumbnail " index)) (list 3 1 6))))

(defn bspwm-desktops [output foci scroll]
  (makebuttons
   (str/join (map-indexed #(bspwm-makedesktopbutton (+ 1 %1) %2 foci) (bspwm-getdesktoplist output)))
   '("$HOME/.scripts/window/act.sh --capturefocuscapture next" "$HOME/.scripts/window/act.sh --capturefocuscapture prev") scroll))


(defn add-elem-if-not-chr-dup [[lst chr] elem] [(if (= elem (first lst) chr) lst (cons elem lst)) chr])

(defn squeeze [string chr] ;for parsing text alignment of wmctrl output, mostly
  (str/join (reverse (first (reduce add-elem-if-not-chr-dup ['() chr] (str/split string #""))))))

(defn getwm []
  (-> "wmctrl -m" exec (str/split #"\n") first (str/split #"\s") second))

(defn getdesktoplist []
  (->> (str/split (exec "wmctrl -d") #"\n") 
       (map #(squeeze % " "))
       (map #(str/split % #"\s"))))

(defn getindex [desktop wm]
  (let [x (-> desktop (nth 0) read-string)]
    (str (if (= wm "CWM") x (+ x 1)))))

(defn getwindows [desktop wm] ;desktop is one line of the output of wmctrl -d
  (exec "xdotool search --desktop" (nth desktop 0) "\"\"" ))

(defn isactive? [desktop] ; only works one at a time in CWM
  (= "*" (nth desktop 1)))

(defn haswindows? [desktop wm] ;causing problems
  (not (str/blank? (getwindows desktop wm))))

(defn getname [desktop wm]
  (case wm
    ("awesome" "bspwm") (nth desktop 8)
    "CWM" (nth desktop 9)
    nil))

(defn makedesktopbutton [d wm foci]
  (let [index (getindex d wm)]
    (str
     ((if (isactive? d) :true (if (haswindows? d wm) :false :dimmed)) foci)
     (makebuttons
      (str " " (getname d wm) " ") (list (str "$HOME/.scripts/window/act.sh -s " index) (str "$HOME/.scripts/window/act.sh --capturefocuscapture " index) (str "$HOME/.scripts/window/act.sh --showthumbnail " index)) (list 3 1 6)))))

(defn desktops [wm foci scroll]
  (makebuttons
   (str/join (drop (if (= wm "CWM") 1 0) (map #(makedesktopbutton % wm foci) (getdesktoplist))))
   '("$HOME/.scripts/window/act.sh --capturefocuscapture next" "$HOME/.scripts/window/act.sh --capturefocuscapture prev") scroll))


(defn music [server scroll]
  (let [serverprefix (if server (str "ssh " server " ") "")
        affix (fn [x] (map #(str serverprefix % " &") x)) ]
    (str
     (makebuttons "  \uf104 " (affix '("mpc prev" "mpc seek 0")) (list 1 3))
     (makebuttons
      (first (str/split (exec (str serverprefix "mpc current")) #"\n"))
      (affix '("mpc toggle" "mpc sendmessage mpdas love" "urxvt -e ncmpcpp -s lyrics" "mpc volume +5" "mpc volume -5")) (list 1 2 3 scroll))
     (makebuttons " \uf105  " (affix '("mpc next" "mpc next")) (list 1 3)))))

(defn date [format] (nth (str/split (:out (sh "date" format)) #"\n") 0))

(defn bat-emoji-format [bat offset section-count] ; f244 f243 f242 f241 f240
  (->> bat (+ 24 (- offset)) (* (/ section-count 100)) int (- 4)  (+ 62016) Character/toChars (apply str))) ; offset of 0 means empty is 0, 1/4 is 1-25, 1/2 is 26-50, 3/4 is 51-75, full is 76-100 where section-count is 4

(defn battery [info foci]
  (if (reduce #(and %1 %2) (map #(-> % info io/file .exists) '(:cap :status)))
    (let [current (-> info :cap slurp str/trim-newline read-string)]
      (if (-> info :status  slurp str/trim-newline (= "Charging"))
        (str (:false foci) " \uf5e7: " current "%")
        (-> current (< (info :threshold)) str keyword foci (str (bat-emoji-format current (info :offset) (info :sections)) ": " current "%"))))   ""))

(defn volume [scroll]
  (makebuttons (str " " (first (str/split-lines (exec "volume query"))) " ") (list "volume +" "volume -" "volume toggle" "volume mute") (list scroll 1 3)))

(defn brightness [info scroll]
  (if (reduce #(and %1 %2) (map #(-> % info io/file .exists) '(:current :max)))
    (makebuttons (str "\uf185: "  (->> (map #(-> % first info slurp read-string) info) (apply /) float (* 100) int) "%") 
      (list "brightnessctl set +10" "brightnessctl set 10-")  scroll)  ""))


(defn store-cmd-in-atom [a & args]
  (let [proc (.exec (Runtime/getRuntime) (into-array args))]
    (with-open [rdr (BufferedReader. (InputStreamReader. (.getInputStream proc)))]
      (dorun
       (map #(reset! a %)
        (take-while  #(pos? (.length %))
              (repeatedly #(.readLine rdr))))))))

;; (defn store-func-in-atom-on-cmd-update [a call & args]
;;   (let [proc (.exec (Runtime/getRuntime) (into-array args))]
;;     (with-open [rdr (BufferedReader. (InputStreamReader. (.getInputStream proc)))]
;;       (loop []
;;         (let [line (.readLine rdr)]
;;           (when (pos? (.length line))
;;             (reset! a (eval call))
;;             (recur)))))))

(defn run-on-atom-change [a func]
  (add-watch a :watcher
    (fn [key atom old-state new-state] (eval func))))


(def wm (getwm))
(def config (-> ".config/lojbar/config.edn" slurp edn/read-string))

(def foci (focus (:color config)))
(def bat (:bat config))
(def bright (:bright config))
(def server (:server config))
(def scroll (if (:natural-scrolling config) '(5 4) '(4 5)))
(def date-format (:date-format config))

(def atoms (into {} (map (fn [k] [k (atom "")]) '(:d :v :m :b :t :br))))


(future (if (= wm "bspwm")
    (store-cmd-in-atom (atoms :d) "bspc" "subscribe")
    (while true (Thread/sleep 100) (reset! (atoms :d) (desktops wm foci scroll)))))  

(future (store-cmd-in-atom (atoms :v) "pactl" "subscribe"))

(dorun (map #(future (while true (Thread/sleep %1) (reset! (atoms %2) (eval %3)))) '(500 500 5000 1000) '(:m :br :b :t) (list '(music server scroll) '(brightness bright scroll) '(battery bat foci) '(date date-format)))) ; set update times and function calls for each polling module

(defn spew [foci]
  (println
   (foci :false) "%{l}  " (if (= wm "bspwm") (bspwm-desktops @(atoms :d) foci scroll) @(atoms :d))
   (foci :false) "%{c}" @(atoms :m) (volume scroll)
   "%{r}" @(atoms :b) (foci :false) @(atoms :br) " " @(atoms :t)  "  "))

(doseq [[_ a] atoms] (run-on-atom-change a '(spew foci))) ; update the bar whenever a module updates
(while true (spew foci) (Thread/sleep 10010000)) ;fails without this, somehow

(shutdown-agents) ;without this it hangs
